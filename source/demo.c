/**
 * demo.c
 *
 * Created by Dimitrios Karageorgiou,
 *  for course "Parallel And Distributed Systems".
 *  Electrical and Computers Engineering Department, AuTh, GR - 2017-2018
 *
 * This file implements an entry point to test provided mean shift
 * implementations.
 *
 * It loads a dataset provided as .karas file and executes mean shift on it,
 * using various implementations, depending on the flags provided at compile
 * time. The following flags are available:
 *  -CPU_ONLY : Builds a variant that utilizes only CPU implementation of
 *          mean shift.
 *  -GPU_ONLY: Builds a variant that utilizes only GPU implementations of
 *          mean shift. Actually there are two implementations. One that
 *          utilizes shared memory and one that does not. The later is only
 *          enabled, if INCLUDE_NOSM flag is provided.
 *  -INCLUDE_NOSM : Enables GPU variant that does not utilize shared memory. It
 *          has no effect if CPU_ONLY is provided.
 *  -<NONE> : All three variants are included and executed.
 *
 * If CPU variant is icluded (i.e. GPU_ONLY flag is NOT present), results of
 * variants executed on GPU are compared against results of CPU variant for
 * validation.
 *
 * Usage:
 *  ./<executable> <data> <scalar>
 * where:
 *  -data : A .karas file containing a matrix with the cords of a set of points
 *          to be used by mean shift.
 *  -scalar : The scalar provided to mean shift algorithm.
 */

#include <stdio.h>
#include <math.h>
#include <sys/time.h>
#include "matrix.h"
#include "utils.h"

// GPU_ONLY flag disables CPU version of mean shift.
#ifndef GPU_ONLY
    #include "mean_shift.h"
#endif

// CPU_ONLY flag disables GPU versions of mean shift.
#ifndef CPU_ONLY
    #include "cuda_mean_shift.h"
    #include "cuda_algebra.h"

    // INCLUDE_NOSM flag enables mean shift version without shared memory
    // usage.
    #ifdef INCLUDE_NOSM
    #include "cuda_mean_shift_nosm.h"
    #endif
#endif


int validate(matrix_t *m1, matrix_t *m2);


int main(int argc, char *argv[])
{
    if (argc < 3) {
        printf("Usage: %s <data> <scaler>\n", argv[0]);
        exit(-1);
    }

    // Load dataset.
    char *data_fn = argv[1];
    matrix_t *data = matrix_load_in_chunks(data_fn, 1, 0);

    // Parse scaler argument.
    double scaler = atof(argv[2]);

    // Structs for calculating elapsed time.
    struct timeval start, stop;

    // References to results generated by each implementation.
    matrix_t *res_cpu = NULL;
    matrix_t *res_gpu = NULL;
    matrix_t *res_gpu_nosm = NULL;

    int pass;  // Indicator that a test has passed.

    // Delimeter for visually separating printed results of each implementation.
    char *delim = "===================================";

#ifndef GPU_ONLY
// Compute mean shift on CPU.
    printf("%s\n", delim);
    gettimeofday(&start, NULL);
    res_cpu = mean_shift(data, scaler, 1E-4);
    gettimeofday(&stop, NULL);
    printf("CPU Total Execution Time: %.3f secs\n",
           get_elapsed_time(start, stop));

#endif

#ifndef CPU_ONLY
// Compute mean shift on GPU without utilizing shared memory.
#ifdef INCLUDE_NOSM
    printf("%s\n", delim);
    gettimeofday(&start, NULL);
    res_gpu_nosm = cuda_mean_shift_nosm(data, scaler, 1E-4, 1);
    gettimeofday(&stop, NULL);
    printf("CUDA (No SM) Total Execution Time: %.3f secs\n",
           get_elapsed_time(start,stop));
    if (res_cpu) {
        pass = validate(res_cpu, res_gpu_nosm);
        printf("CUDA (No SM) Test: %s\n", pass ? "SUCCESS" : "FAIL");
    }
#endif


// Compute mean shift on GPU by utilizing shared memory..
    printf("%s\n", delim);
    gettimeofday(&start, NULL);
    res_gpu = cuda_mean_shift(data, scaler, 1E-4, 1);
    gettimeofday(&stop, NULL);
    printf("CUDA Total Execution Time: %.3f secs\n",
           get_elapsed_time(start,stop));
    if (res_cpu) {
        pass = validate(res_cpu, res_gpu);
        printf("CUDA Test: %s\n", pass ? "SUCCESS" : "FAIL");
    }
#endif

    if (res_cpu) matrix_destroy(res_cpu);
    if (res_gpu_nosm) matrix_destroy(res_gpu_nosm);
    if (res_gpu) matrix_destroy(res_gpu);
    if (data) matrix_destroy(data);

    return 0;
}

/**
 * Validates the results of a mean shift implementation,
 * by comparing them againt the results of an already tested
 * implementation.
 *
 * Parameters:
 *  -m1 : Results of mean shift implementation 1.
 *  -m2 : Results of mean shift implementation 2.
 *
 * Returns:
 *  1 on success, 0 upon failure.
 */
int validate(matrix_t *m1, matrix_t *m2)
{
    for (int i = 0; i < matrix_get_rows(m1); i++) {
        for (int j = 0; j < matrix_get_cols(m1); j++) {
            double c1 = matrix_get_cell(m1, i, j);
            double c2 = matrix_get_cell(m2, i, j);
            if (fabs(c1 - c2) > 0.01) {
                printf("%d %d : Expected %f - Actual %f\n", i, j, c1, c2);
                //return 0;
            }
        }
    }

    return 1;
}
